#' @title Calculate posterior mean genetic liabilities
#'
#' @description to be written
#'
#' @param pheno_file path to file with information on liabilities, with same
#' format as "phenotypes.txt" generated by the simulation functions in
#' geneference.
#' @param sibs number of siblings in the families. If family size varies,
#' specify the number of siblings in the largest family.
#' @param output_file path of output file. This can be the same as
#' \Code{pheno_file}.
#' @param alpha significance level used for deciding phenotype status based on
#' liabilities.
#'
#'
#' @return Does not return anything, but writes a \Code{output_file} to disk,
#' where configuration, configuration class and posterior mean genetic
#' liability is appended to the end of \Code{pheno_file}.
#'
#' @importFrom magrittr `%>%`
#' @import dplyr
#' @import tidyr
#' @import tibble
#' @import data.table
#'
#' @export
assign_ltfh_phenotype <- function(pheno_file,
                                  sibs,
                                  output_file = pheno_file,
                                  alpha) {

  stopifnot("pheno_file needs to be a valid file" = file.exists(pheno_file),
            "sibs needs to be an integer of size 0 or more" = (class(sibs) == "numeric" && sibs == round(sibs) && 0 <= sibs),
            "output_file" = TRUE,  # fix det Rasmus
            "alpha needs to be numeric and between 0 and 1" = (class(alpha) == "numeric" && 0 < alpha && alpha < 1))


  crit <- qnorm(1 - alpha)

  # helper function for determining phenotype status based on liabilities
  onetwo <- function(x) {
    dplyr::if_else(x >= crit, 2, 1)
  }

  # helper function for finding equivalent configurations
  create_conf_class <- function(LTFH_key) {
    key_split <- strsplit(LTFH_key, "")
    child <- key_split[[1]][1]
    parent_sum <- sum(as.numeric(key_split[[1]][2:3]))
    n_sibs <- nchar(LTFH_key) - 3
    sibs_sum <- sum(as.numeric(tail(key_split[[1]], -3)))
    conf_class <- paste(child, parent_sum, n_sibs, sibs_sum, sep = "x")
    return(conf_class)
  }

  # Liability for child, par1 and par2
  liability_columns <- c(5, 8, 11)

  # Liability for siblings
  if (sibs > 0) {
    liability_columns <- c(liability_columns, 11 + (1:sibs * 3))
  }

  # Import phenotypes
  pheno <- tibble::tibble(data.table::fread(pheno_file))

  # Create configurations (LTFH_key)
  pheno <- dplyr::bind_cols(pheno,
                            tidyr::unite(data = tibble::as_tibble(
                              apply(pheno[, liability_columns], 2, onetwo)),
                              col = LTFH_key, sep = "", remove = F)[, 1])


  # Table of configurations and which configuration class they belong to
  table_1 <- dplyr::distinct(pheno, LTFH_key) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(conf_class = create_conf_class(LTFH_key))


  # Table of configuration classes and their posterior mean genetic liability
  table_2 <- dplyr::distinct(table_1, conf_class, .keep_all = TRUE) %>%
    dplyr::mutate(LTFH_pheno = Gibbs(conf = LTFH_key,
                                     burn_in = 200,
                                     start_value = 3,
                                     alpha = alpha)) %>%
    dplyr::select(conf_class, LTFH_pheno)

  # Joining table_1 and table_2 by conf_class
  table_3 <- dplyr::left_join(table_1, table_2, by = "conf_class")

  # Joining such that new columns are appended to the tibble imported from
  # phenofile
  pheno <- dplyr::left_join(pheno, table_3, by = "LTFH_key")

  #write to file
  data.table::fwrite(x = pheno, file = output_file,
                     quote = F,
                     sep = " ",
                     col.names = T,
                     append = F)
}

#' @title Create case-control status by proxy
#'
#' @description to be written
#'
#' @param pheno_file path to file with information on phenotype status, with
#' same format as "phenotypes.txt" generated by the simulation functions in
#' geneference.
#' @param output_file path of output file. This can be the same as
#' \Code{pheno_file}.
#' @param sibs number of siblings in the families. If family size varies,
#' specify the number of siblings in the largest family.
#'
#'
#' @return Does not return anything, but writes \Code{output_file} to disk,
#' where the GWAX phenotype column is appended to the end of \Code{pheno_file}.
#'
#' @import data.table
#'
#' @export
assign_GWAX_phenotype <- function(pheno_file,
                                  output_file = pheno_file,
                                  sibs = 0) {

  stopifnot("pheno_file needs to be a valid file" = file.exists(pheno_file),
            "output_file" = TRUE,  # fix det Rasmus
            "sibs needs to be an integer of size 0 or more" = (class(sibs) == "numeric" && sibs == round(sibs) && 0 <= sibs))


  # Read the file
  pheno <- tibble::tibble(data.table::fread(pheno_file))

  # Columns with phenotypes for child, parent 1 and parent 2
  pheno_cols <- seq(3, 10, 3)

  # Columns with phenotypes for siblings
  if (sibs > 0) {
    pheno_cols <- c(pheno_cols, 9 + (1:sibs * 3))
  }

  # Set GWAX phenotype to maximum of the phenotypes in the family
  pheno[, "GWAX_pheno"] <- apply(pheno[, pheno_cols], 1, max, na.rm = TRUE)

  # Write to file
  data.table::fwrite(x = pheno, file = output_file,
                     quote = F,
                     sep = " ",
                     col.names = T,
                     append = F)
}
