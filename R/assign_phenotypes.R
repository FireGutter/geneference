#' @title Calculate posterior mean genetic liabilities
#'
#' @description to be written. Note: sibs argument can be used for using a
#' dataset with many siblings as a dataset with fewer siblings. Include this
#' in \code{vignette("geneference")}.
#'
#' @param pheno_file path to file with information on liabilities, with same
#' format as "phenotypes.txt" generated by the simulation functions in
#' geneference.
#' @param output_file path of output file. This is by default the same as
#' \code{pheno_file}.
#' @param alpha significance level used for deciding phenotype status based on
#' liabilities.
#' @param sibs \emph{optional:} number of siblings in the families to be used
#' for calculating posterior mean genetic liabilities. Defaults to using all
#' of an individual's siblings.
#'
#'
#' @return Does not return anything, but writes a \code{output_file} to disk,
#' where configuration, configuration class and posterior mean genetic
#' liability is appended to the end of \code{pheno_file}.
#'
#' @import utils
#'
#' @export
assign_ltfh_phenotype <- function(pheno_file,
                                  output_file = pheno_file,
                                  alpha,
                                  sibs) {

  stopifnot("pheno_file needs to be a valid file" = file.exists(pheno_file),
            "output_file needs to be a valid file path ending with '.txt'" =
              (tools::file_ext(output_file) == "txt"),
            "alpha needs to be a number between 0 and 1" =
              (is.numeric(alpha) && 0 < alpha && alpha < 1),
            "sibs needs to be a non-negative integer less than or equal to number of siblings in pheno_file" =
              (missing(sibs) ||
                 (is.numeric(sibs) && sibs == round(sibs) &&
                    0 <= sibs && sibs <= n_sibs(load_phenotypes(pheno_file)))))

  # import phenotypes.
  pheno <- load_phenotypes(pheno_file)
  
  # if sibs isn't specified we just assign the max number of siblings in data
  if (missing(sibs)) {
    sibs <- n_sibs(pheno)
  }

  crit <- qnorm(1 - alpha)

  # helper function for determining phenotype status based on liabilities
  onetwo <- function(x) {
    dplyr::if_else(x != -9, dplyr::if_else(x >= crit, "2", "1"), "")
  }

  # helper function for finding equivalent configurations
  create_conf_class <- function(LTFH_key) {
    key_split <- strsplit(LTFH_key, "")
    child <- key_split[[1]][1]
    parent_sum <- sum(as.numeric(key_split[[1]][2:3]))
    n_sibs <- nchar(LTFH_key) - 3
    sibs_sum <- sum(as.numeric(tail(key_split[[1]], -3)))
    conf_class <- paste(child, parent_sum, n_sibs, sibs_sum, sep = "x")
    return(conf_class)
  }

  # Liability for child, par1 and par2
  liability_columns <- c(5, 8, 11)

  # Liability for siblings
  if (sibs > 0) {
    liability_columns <- c(liability_columns, 11 + (1:sibs * 3))
  }


  # Create configurations (LTFH_key)
  pheno <- dplyr::bind_cols(pheno,
                            tidyr::unite(data = tibble::as_tibble(
                              apply(pheno[, liability_columns], 2, onetwo)),
                              col = LTFH_key, sep = "", remove = F)[, 1])


  # Table of configurations and which configuration class they belong to
  table_1 <- dplyr::distinct(pheno, LTFH_key) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(conf_class = create_conf_class(LTFH_key))


  # Table of configuration classes and their posterior mean genetic liability
  table_2 <- dplyr::distinct(table_1, conf_class, .keep_all = TRUE) %>%
    dplyr::mutate(LTFH_pheno = generate_pmgl(conf = LTFH_key,
                                     burn_in = 200,
                                     start_value = 3,
                                     alpha = alpha)) %>%
    dplyr::select(conf_class, LTFH_pheno)

  # Joining table_1 and table_2 by conf_class
  table_3 <- dplyr::left_join(table_1, table_2, by = "conf_class")

  # Joining such that new columns are appended to the tibble imported from
  # phenofile
  pheno <- dplyr::left_join(pheno, table_3, by = "LTFH_key")

  #write to file
  data.table::fwrite(x = pheno, file = output_file,
                     quote = F,
                     sep = " ",
                     col.names = T,
                     append = F)
}

#' @title Create case-control status by proxy
#'
#' @description to be written. Note: sibs argument can be used for using a
#' dataset with many siblings as a dataset with fewer siblings. Include this
#' in \code{vignette("geneference")}.
#'
#' @param pheno_file path to file with information on phenotype status, with
#' same format as "phenotypes.txt" generated by the simulation functions in
#' geneference.
#' @param output_file path of output file. This is by default the same as
#' \code{pheno_file}.
#' @param sibs \emph{optional:} specify number of siblings to use for proxy.
#' Defaults to using all of an individual's siblings.
#'
#'
#' @return Does not return anything, but writes \code{output_file} to disk,
#' where the GWAX phenotype column is appended to the end of \code{pheno_file}. 
#'
#' @export
assign_GWAX_phenotype <- function(pheno_file,
                                  output_file = pheno_file,
                                  sibs) {

  stopifnot("pheno_file needs to be a valid file" = file.exists(pheno_file),
            "output_file needs to be a valid file path ending with '.txt'" =
              (tools::file_ext(output_file) == "txt"),
            "sibs needs to be a non-negative integer less than or equal to number of siblings in pheno_file" =
              (missing(sibs) ||
                 (is.numeric(sibs) && sibs == round(sibs) &&
                    0 <= sibs && sibs <= n_sibs(load_phenotypes(pheno_file)))))

  # Read the file
  pheno <- load_phenotypes(pheno_file)

  # if sibs isn't specified we just assign the max number of siblings in data
  if (missing(sibs)) {
    sibs <- n_sibs(pheno)
  }
  
  # Columns with phenotypes for child, parent 1 and parent 2
  pheno_cols <- seq(3, 10, 3)

  # Columns with phenotypes for siblings
  if (sibs > 0) {
    pheno_cols <- c(pheno_cols, 9 + (1:sibs * 3))
  }

  # Set GWAX phenotype to maximum of the phenotypes in the family
  pheno[, "GWAX_pheno"] <- apply(pheno[, pheno_cols], 1, max, na.rm = TRUE)

  # Write to file
  data.table::fwrite(x = pheno, file = output_file,
                     quote = F,
                     sep = " ",
                     col.names = T,
                     append = F)
}
